# Common Table Expressions, подзапросы, временные таблицы и табличные переменные

## Подзапросы
Вложенный запрос (подзапрос) - когда один запрос вложенный в другой  
```
SELECT name, surname
FROM actor
WHERE actor_id  in (
    SELECT person_id FROM persons WHERE person_name = 'john'
) 
```
Бывают двух типов:
1. Независимые
```
SELECT 
    StockItemID,
    (SELECT MAX(UnitPrice)
    FROM StockItems) AS MaxPrice
FROM StockItems;
```
2. Зависимые (correlated) - когда подзапрос ссылается на внешнюю таблицу

Важное:  
+ Подзапрос может возвращать одно значение, может несколько, либо таблицу - (derived tables).  
+ Когда данных не много, то проще сделать JOIN.  

Операторы используемые с подзапросами:
* IN или NOT IN
* EXISTS или NOT EXISTS
Быстрее, чем IN
* ANY (SOME) - хотя бы одно значение
= SOME -> IN
```
WHERE UnitPrice <= SOME (SELECT UnitPrice FROM StockItems)
```
* ALL 

## Обобщенные табличные выражения (CTE)
По сути это именованный подзапрос:
```
WITH [название] (поля) 
AS ( подзапрос )
SELECT .....
```

Важное:  
* СTE хранться в памяти
* Можно использовать несколько CTE в одном запросе, но CTE используется только один раз.  
* Можно удалять из CTE 
* Можно делать JOIN нескольких CTE

## Оконные функции

Необходимы для выполнения следующих целей:
- нарастающий итог
- в запросе нужны данные из предыдущей строки
- нужно совместить и сами данные, и агрегаты
- выбрать топ 3 из группы: топ 3 самых дорогих товара в каждой группе
- разделить набор на N групп

```
Function() OVER (
    окно по которому идет расчет
)
```

```
Func() OVER (
    PARTITION BY [список полей]
    ORDER BY
    ROWS/RANGE
)
```

пустое `OVER()` - по всем строкам   

Какие функции бывают:
1. Ранжирующие (`ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `NTILE(кол-во групп)`)
2. Функции смещения (`LAG(поле, [смещение], default)`, `LEAD(поле, [смещение], default)`,
`FIRST_VALUE(поле, [смещение], default)`, `LAST_VALUE(поле, [смещение], default)`)
3. Распределения (`CUME_DIST()`, `Percentile_COUNT()`, `Percentile_DISC()`, `Percent_RANK()`)
4. Агрегатные (`SUM()`, `COUNT()`, `COUNT_BIG()`, `AVG()`, `MIN()`, `MAX()`)

## Временные таблицы

Временная таблица компактная и содержит тот набор данных, который нужен для вычислений.

Особенности:  
- есть ключи, можно джоинить 
- не храниться в БД и по имени обратиться нельзя
- не доступна из другого скоупа. Физически живет в tempdb. 

Локальные существуют в рамках процедуры. Глобальные инициируются при запуске sql сервера и доступны по имени.  

```
create table #T (id not null);
```

### Временные таблицы в PostgreSQL
В PostrgeSQL механизма временных таблиц tempdb нет, поэтому использование временных таблиц крайне нежелательно.
Использовать их лучше тогда, когда нет другой возможности.

<details>
<summary>Подробнее</summary>
В MS SQL для временных таблиц имеется выделенная база данных (tempdb), работа с которой оптимизирована именно для 
хранения временных объектов и довольно сильно отличается от работы с любой другой БД. В PostgreSQL любые запросы могут 
оперировать только с объектами одной БД. Механизмы dblink() или FDW - это далеко не одновременный доступ к объектам 
нескольких БД на одном сервере в одном запросе, как в MS SQL. Поэтому временные таблицы не только располагаются в 
текущей БД, но и все их метаданные размещаются в постоянных системных таблицах текущей БД. И если доступ к данным самих 
временных таблиц так же оптимизирован и упрощен, как в MS SQL, то операции с метаданными временных и постоянных таблиц, 
по большому счету, ничем не отличаются. [Источник](https://habr.com/ru/articles/773972/)
</details>

